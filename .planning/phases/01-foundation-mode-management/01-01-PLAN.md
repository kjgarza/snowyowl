---
phase: 01-foundation-mode-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/config.sh
autonomous: true

must_haves:
  truths:
    - "SNOWYOWL_MODE=gsd results in GSD mode detection"
    - "SNOWYOWL_MODE=tasks results in TASKS mode detection"
    - "Without SNOWYOWL_MODE, file presence (.planning/ or TASKS.md) determines mode"
    - "Invalid SNOWYOWL_MODE produces clear error and exits"
    - "GSD events logged to dedicated gsd_*.log files"
    - "Phase execution logs include timestamps, duration, and exit codes"
  artifacts:
    - path: "lib/config.sh"
      provides: "Mode detection and GSD logging"
      contains: "detect_execution_mode"
    - path: "lib/config.sh"
      provides: "Mode validation"
      contains: "validate_mode"
    - path: "lib/config.sh"
      provides: "GSD logging functions"
      contains: "log_gsd"
    - path: "lib/config.sh"
      provides: "Dry-run helper"
      contains: "execute_or_dry_run"
  key_links:
    - from: "detect_execution_mode"
      to: "SNOWYOWL_MODE env var"
      via: "checks environment variable first"
      pattern: 'SNOWYOWL_MODE:-'
    - from: "log_gsd"
      to: "GSD_LOG file"
      via: "tee to separate log file"
      pattern: 'tee.*GSD_LOG'
    - from: "log_phase_end"
      to: "PHASE_START_TIME"
      via: "calculates duration"
      pattern: 'end_time.*PHASE_START_TIME'
---

<objective>
Extend lib/config.sh with mode detection, GSD logging infrastructure, and dry-run helpers.

Purpose: Establish the foundation for dual-mode operation (TASKS vs GSD) with comprehensive logging for overnight execution visibility.

Output: Extended lib/config.sh with:
- detect_execution_mode() function for cascading mode detection
- validate_mode() function for fail-fast on invalid modes
- GSD logging functions (init_gsd_logging, log_gsd, log_phase_start, log_phase_end, log_scan_result)
- execute_or_dry_run() helper for consistent dry-run behavior
</objective>

<execution_context>
@/Users/kristiangarza/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kristiangarza/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-mode-management/01-RESEARCH.md
@lib/config.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mode detection functions to lib/config.sh</name>
  <files>lib/config.sh</files>
  <action>
Add mode detection functions to lib/config.sh. Insert after the existing logging functions (after line 148).

Add these globals near the top (after line 16, after TIMESTAMP):
```bash
# Execution mode: gsd or tasks (set by detect_execution_mode)
EXECUTION_MODE=""
```

Add the following functions:

1. `detect_execution_mode()` - Cascading detection:
   - Priority 1: Check SNOWYOWL_MODE environment variable (case-insensitive)
   - Priority 2: Check file presence (.planning/ = gsd, TASKS.md = tasks)
   - Priority 3: Default to "tasks" for backward compatibility
   - Takes optional $1 for target directory (default: current dir)
   - Sets global EXECUTION_MODE
   - Logs which detection method was used
   - Returns 1 if SNOWYOWL_MODE is set but invalid

2. `validate_mode()` - Fail-fast validation:
   - Takes $1 as mode to validate
   - Returns 0 for "gsd" or "tasks"
   - Logs error and returns 1 for unknown modes

Use the exact implementation from 01-RESEARCH.md "Mode Detection Implementation" section. Normalize SNOWYOWL_MODE to lowercase using `tr '[:upper:]' '[:lower:]'` before comparison.
  </action>
  <verify>
1. Source the config: `source lib/config.sh`
2. Test env var detection: `SNOWYOWL_MODE=gsd detect_execution_mode; echo $EXECUTION_MODE` should output "gsd"
3. Test case insensitivity: `SNOWYOWL_MODE=GSD detect_execution_mode; echo $EXECUTION_MODE` should output "gsd"
4. Test invalid mode: `SNOWYOWL_MODE=invalid detect_execution_mode` should return non-zero exit code
5. Test file presence: Create temp dir with .planning/, run `detect_execution_mode /tmp/test`, verify outputs "gsd"
  </verify>
  <done>
- EXECUTION_MODE global declared
- detect_execution_mode() function exists and handles all three priorities
- validate_mode() function exists and rejects unknown modes
- Mode detection logs which method was used
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GSD logging infrastructure to lib/config.sh</name>
  <files>lib/config.sh</files>
  <action>
Add GSD-specific logging functions to lib/config.sh. Insert after the mode detection functions added in Task 1.

Add these globals near the other globals:
```bash
# GSD-specific logging
GSD_LOG=""
PHASE_START_TIME=0
```

Add the following functions:

1. `init_gsd_logging()` - Initialize GSD log file:
   - Only creates GSD log if EXECUTION_MODE is "gsd"
   - Sets GSD_LOG to "$LOG_DIR/gsd_${TIMESTAMP}.log"
   - Creates the file with touch
   - Logs the GSD log file path

2. `log_gsd()` - Log with phase context:
   - Arguments: $1=phase (or "scan"), $2=message, $3=level (default INFO)
   - Format: "[timestamp] [level] [Phase N] message"
   - Writes to both GSD_LOG and MAIN_LOG using tee
   - Falls back to regular log() if GSD_LOG not initialized

3. `log_phase_start()` - Log phase start with timing:
   - Arguments: $1=phase, $2=repo (optional)
   - Records PHASE_START_TIME=$(date +%s)
   - Logs start banner and repo if provided

4. `log_phase_end()` - Log phase end with duration:
   - Arguments: $1=phase, $2=exit_code (default 0)
   - Calculates duration from PHASE_START_TIME
   - Uses ERROR level if exit_code non-zero
   - Logs completion banner with exit code and duration

5. `log_scan_result()` - Log readiness scan:
   - Arguments: $1=repo, $2=ready_phases, $3=reason (optional)
   - Logs whether repo is ready and which phases
   - Logs reason if not ready

Use implementations from 01-RESEARCH.md "GSD Logging Functions" section.
  </action>
  <verify>
1. Source config and init: `source lib/config.sh && init_directories && EXECUTION_MODE=gsd && init_gsd_logging`
2. Check GSD log created: `ls -la $LOG_DIR/gsd_*.log`
3. Test log_gsd: `log_gsd "1" "Test message" "INFO"` should write to both logs
4. Test timing: `log_phase_start "1" "testrepo"; sleep 1; log_phase_end "1" "0"` should show ~1s duration
5. Test scan logging: `log_scan_result "myrepo" "1,2" ""` should log ready phases
  </verify>
  <done>
- GSD_LOG and PHASE_START_TIME globals declared
- init_gsd_logging() creates separate GSD log file
- log_gsd() writes with phase context to both logs
- log_phase_start() and log_phase_end() track timing
- log_scan_result() logs readiness with phase list or reason
  </done>
</task>

<task type="auto">
  <name>Task 3: Add dry-run helper function to lib/config.sh</name>
  <files>lib/config.sh</files>
  <action>
Add a generalized dry-run helper function to lib/config.sh. Insert after the GSD logging functions.

Add the following functions:

1. `execute_or_dry_run()` - Execute command or log in dry-run mode:
   - Arguments: $1=description, $@=command and args
   - If DRY_RUN is true: logs what would happen and returns 0
   - If DRY_RUN is false: executes the command and returns its exit code
   - Log format for dry-run: "[DRY RUN] Would: description" and "[DRY RUN] Command: ..."

2. `should_execute()` - Simple dry-run check:
   - Returns 0 if DRY_RUN is not true (should execute)
   - Returns 1 if DRY_RUN is true (should skip)
   - Usage: `if should_execute; then <do_thing>; fi`

Use implementations from 01-RESEARCH.md "Dry-Run Mode Extension" section.
  </action>
  <verify>
1. Source config: `source lib/config.sh && init_directories`
2. Test execute mode: `DRY_RUN=false execute_or_dry_run "list files" ls -la` should execute ls
3. Test dry-run mode: `DRY_RUN=true execute_or_dry_run "list files" ls -la` should only log, not execute
4. Test should_execute: `DRY_RUN=true; if should_execute; then echo "bad"; else echo "good"; fi` should print "good"
  </verify>
  <done>
- execute_or_dry_run() function handles both dry-run and real execution
- should_execute() provides simple boolean check
- Dry-run logs include description and full command
  </done>
</task>

</tasks>

<verification>
After all tasks complete, run comprehensive verification:

```bash
cd /Users/kristiangarza/aves/snowyowl

# 1. Verify syntax
bash -n lib/config.sh && echo "Syntax OK"

# 2. Test mode detection scenarios
source lib/config.sh && init_directories

# Scenario A: Env var takes precedence
SNOWYOWL_MODE=gsd detect_execution_mode
[[ "$EXECUTION_MODE" == "gsd" ]] && echo "ENV VAR TEST: PASS" || echo "ENV VAR TEST: FAIL"

# Scenario B: Case insensitivity
unset EXECUTION_MODE
SNOWYOWL_MODE=GSD detect_execution_mode
[[ "$EXECUTION_MODE" == "gsd" ]] && echo "CASE TEST: PASS" || echo "CASE TEST: FAIL"

# Scenario C: Invalid mode rejected
unset EXECUTION_MODE
SNOWYOWL_MODE=invalid detect_execution_mode 2>/dev/null
[[ $? -ne 0 ]] && echo "INVALID MODE TEST: PASS" || echo "INVALID MODE TEST: FAIL"

# 3. Test GSD logging
unset SNOWYOWL_MODE
EXECUTION_MODE=gsd
init_gsd_logging
[[ -f "$GSD_LOG" ]] && echo "GSD LOG TEST: PASS" || echo "GSD LOG TEST: FAIL"

# 4. Test dry-run
DRY_RUN=true
execute_or_dry_run "test echo" echo "should not print"
# Should only see "[DRY RUN]" log messages, not "should not print"
```
</verification>

<success_criteria>
1. lib/config.sh passes bash syntax check (`bash -n lib/config.sh`)
2. SNOWYOWL_MODE=gsd correctly detected (env var priority)
3. SNOWYOWL_MODE=tasks correctly detected (env var priority)
4. SNOWYOWL_MODE=GSD (uppercase) normalized to gsd
5. Invalid SNOWYOWL_MODE produces error and non-zero exit
6. File presence fallback works (.planning/ -> gsd, TASKS.md -> tasks)
7. Default fallback is "tasks" when no indicators present
8. GSD log file created at $LOG_DIR/gsd_${TIMESTAMP}.log when mode is gsd
9. Phase timing logged correctly (start/end with duration)
10. Dry-run mode prevents command execution while logging intent
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-mode-management/01-01-SUMMARY.md`
</output>
